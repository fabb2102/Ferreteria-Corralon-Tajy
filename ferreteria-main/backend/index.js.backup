const express = require('express');
const cors = require('cors');
const puppeteer = require('puppeteer');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');

const app = express();
app.use(cors());
app.use(express.json());

// JWT secret key (in production, use environment variable)
const JWT_SECRET = 'ferreteria_secret_key_2024';

// Helper function to hash passwords with MD5
const hashPasswordMD5 = (plainPassword) => {
  return crypto.createHash('md5').update(plainPassword).digest('hex');
};

// Helper function to hash passwords for new users (bcrypt - deprecated)
// Usage: const hashedPassword = await hashPassword('plaintext123');
const hashPassword = async (plainPassword) => {
  const saltRounds = 12;
  return await bcrypt.hash(plainPassword, saltRounds);
};

// TODO: When implementing user creation/editing endpoints, use hashPasswordMD5()
// Example:
// app.post('/api/usuarios', async (req, res) => {
//   const { email, password, nombre, rolId } = req.body;
//   const hashedPassword = hashPasswordMD5(password);
//   // Save user with hashedPassword (MD5) instead of plain password
// });

// Mock data stores (replace with database in production)
let productos = [
  { id: 1, codigo: 'PRD001', nombre: 'Martillo', precio: 25500, costo: 15000, stock: 15, categoria: 'Herramientas', proveedor: 'Proveedor A', activo: true },
  { id: 2, codigo: 'PRD002', nombre: 'Destornillador', precio: 12000, costo: 7000, stock: 30, categoria: 'Herramientas', proveedor: 'Proveedor B', activo: true },
  { id: 3, codigo: 'PRD003', nombre: 'Tornillos', precio: 5750, costo: 3000, stock: 100, categoria: 'Accesorios', proveedor: 'Proveedor C', activo: true }
];

let clientes = [
  { id: 1, nombre: 'Juan P√©rez', email: 'juan@email.com', telefono: '123-456-7890' },
  { id: 2, nombre: 'Mar√≠a Garc√≠a', email: 'maria@email.com', telefono: '987-654-3210' },
  { id: 3, nombre: 'Carlos L√≥pez', email: 'carlos@email.com', telefono: '555-123-4567' }
];

// Roles and Users data
let roles = [
  { id: 1, nombre: 'Administrador', descripcion: 'Acceso completo al sistema' },
  { id: 2, nombre: 'Vendedor', descripcion: 'Puede gestionar ventas y clientes' }
];

// Default users (passwords hashed with MD5)
let usuarios = [
  { 
    id: 1, 
    email: 'admin@ferreteria.com', 
    password: '0192023a7bbd73250516f069df18b500', // admin123 MD5
    nombre: 'Administrador', 
    rolId: 1,
    activo: true,
    fechaCreacion: '2024-01-01T00:00:00.000Z',
    ultimoAcceso: new Date().toISOString()
  },
  { 
    id: 2, 
    email: 'vendedor@ferreteria.com', 
    password: 'a60c36fc7c825e68bb5371a0e08f828a', // vendedor123 MD5
    nombre: 'Juan Vendedor', 
    rolId: 2,
    activo: true,
    fechaCreacion: '2024-01-01T00:00:00.000Z',
    ultimoAcceso: '2024-10-15T10:30:00.000Z'
  }
];

let ventas = [];
let nextVentaId = 1;
let nextProductoId = 4;
let nextClienteId = 4;
let nextUsuarioId = 3;

// Proveedores data
let proveedores = [
  { id: 1, nombre: 'Distribuidora Central S.A.', ruc: '80012345-7', telefono: '021-555-0001', direccion: 'Av. Mariscal L√≥pez 1234, Asunci√≥n' },
  { id: 2, nombre: 'Ferreter√≠a Industrial del Este', ruc: '80023456-8', telefono: '061-444-0002', direccion: 'Ruta 2 Km 15, Ciudad del Este' },
  { id: 3, nombre: 'Pinturas y Acabados SA', ruc: '80034567-9', telefono: '021-333-0003', direccion: 'Av. Espa√±a 567, Asunci√≥n' }
];

// Compras data
let compras = [];
let nextProveedorId = 4;
let nextCompraId = 1;

// Categor√≠as data
let categorias = [
  { id: 1, nombre: 'Herramientas' },
  { id: 2, nombre: 'Materiales de Construcci√≥n' },
  { id: 3, nombre: 'Pintura' },
  { id: 4, nombre: 'Electricidad' },
  { id: 5, nombre: 'Plomer√≠a' },
  { id: 6, nombre: 'Ferreter√≠a General' },
  { id: 7, nombre: 'Jardiner√≠a' },
  { id: 8, nombre: 'Seguridad' }
];

// Authentication middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

  if (!token) {
    return res.status(401).json({ error: 'Token de acceso requerido' });
  }

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ error: 'Token inv√°lido' });
    }
    req.user = user;
    next();
  });
};

// Authorization middleware
const authorize = (allowedRoles = []) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ error: 'Usuario no autenticado' });
    }

    const userRole = roles.find(role => role.id === req.user.rolId);

    if (allowedRoles.length && !allowedRoles.includes(userRole?.nombre)) {
      return res.status(403).json({ 
        error: 'No tienes permisos para realizar esta acci√≥n',
        requiredRoles: allowedRoles,
        userRole: userRole?.nombre 
      });
    }

    next();
  };
};

// Authentication endpoints
app.post('/api/auth/login', async (req, res) => {
  const { email, password } = req.body;

  if (!email || !password) {
    return res.status(400).json({ error: 'Email y contrase√±a son requeridos' });
  }

  // Find user
  const usuario = usuarios.find(u => u.email === email && u.activo);
  if (!usuario) {
    return res.status(401).json({ error: 'Credenciales inv√°lidas' });
  }

  // Verify password using MD5 hash
  const passwordMD5 = hashPasswordMD5(password);
  const passwordValida = passwordMD5 === usuario.password;
  
  if (!passwordValida) {
    return res.status(401).json({ error: 'Credenciales inv√°lidas' });
  }

  // Update last access time
  const usuarioIndex = usuarios.findIndex(u => u.id === usuario.id);
  if (usuarioIndex !== -1) {
    usuarios[usuarioIndex].ultimoAcceso = new Date().toISOString();
  }

  // Get user role
  const rol = roles.find(r => r.id === usuario.rolId);

  // Generate JWT token
  const token = jwt.sign(
    { 
      id: usuario.id, 
      email: usuario.email, 
      rolId: usuario.rolId,
      rol: rol.nombre 
    },
    JWT_SECRET,
    { expiresIn: '8h' }
  );

  res.json({
    token,
    usuario: {
      id: usuario.id,
      email: usuario.email,
      nombre: usuario.nombre,
      rol: {
        id: rol.id,
        nombre: rol.nombre,
        descripcion: rol.descripcion
      }
    }
  });
});

// Get current user info
app.get('/api/auth/me', authenticateToken, (req, res) => {
  const usuario = usuarios.find(u => u.id === req.user.id);
  const rol = roles.find(r => r.id === usuario.rolId);

  if (!usuario) {
    return res.status(404).json({ error: 'Usuario no encontrado' });
  }

  res.json({
    id: usuario.id,
    email: usuario.email,
    nombre: usuario.nombre,
    rol: {
      id: rol.id,
      nombre: rol.nombre,
      descripcion: rol.descripcion
    }
  });
});

// Helper function to generate random password
const generateRandomPassword = () => {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let result = 'TEMP';
  for (let i = 0; i < 6; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
};

// API Endpoints for Usuarios (User Management)
app.get('/api/usuarios', authenticateToken, authorize(['Administrador']), (req, res) => {
  try {
    const usuariosConRol = usuarios.map(usuario => {
      const rol = roles.find(r => r.id === usuario.rolId);
      const { password, ...usuarioSinPassword } = usuario;
      
      return {
        ...usuarioSinPassword,
        rol: {
          id: rol.id,
          nombre: rol.nombre
        }
      };
    });
    
    res.json(usuariosConRol);
  } catch (error) {
    res.status(500).json({ error: 'Error al obtener usuarios' });
  }
});

app.post('/api/usuarios', authenticateToken, authorize(['Administrador']), (req, res) => {
  try {
    const { nombre, email, password, rolId } = req.body;
    
    // Validaciones
    if (!nombre || !email || !password || !rolId) {
      return res.status(400).json({ error: 'Todos los campos son obligatorios' });
    }
    
    // Verificar email √∫nico
    const emailExiste = usuarios.find(u => u.email.toLowerCase() === email.toLowerCase());
    if (emailExiste) {
      return res.status(400).json({ error: 'El email ya est√° registrado' });
    }
    
    // Verificar que el rol existe
    const rol = roles.find(r => r.id === parseInt(rolId));
    if (!rol) {
      return res.status(400).json({ error: 'Rol inv√°lido' });
    }
    
    // Crear nuevo usuario
    const nuevoUsuario = {
      id: nextUsuarioId++,
      nombre,
      email: email.toLowerCase(),
      password: hashPasswordMD5(password),
      rolId: parseInt(rolId),
      activo: true,
      fechaCreacion: new Date().toISOString(),
      ultimoAcceso: null
    };
    
    usuarios.push(nuevoUsuario);
    
    // Respuesta sin contrase√±a hasheada
    const { password: _, ...usuarioRespuesta } = nuevoUsuario;
    res.json({
      usuario: {
        ...usuarioRespuesta,
        rol: {
          id: rol.id,
          nombre: rol.nombre
        }
      },
      credencialesTemporales: {
        email: email,
        password: password,
        mensaje: 'Guarda estas credenciales para entregar al usuario'
      }
    });
  } catch (error) {
    res.status(500).json({ error: 'Error al crear usuario' });
  }
});

app.put('/api/usuarios/:id', authenticateToken, authorize(['Administrador']), (req, res) => {
  try {
    const id = parseInt(req.params.id);
    const { nombre, email, rolId, activo } = req.body;
    
    const usuarioIndex = usuarios.findIndex(u => u.id === id);
    if (usuarioIndex === -1) {
      return res.status(404).json({ error: 'Usuario no encontrado' });
    }
    
    // No permitir que el admin se desactive a s√≠ mismo
    if (req.user.id === id && activo === false) {
      return res.status(400).json({ error: 'No puedes desactivar tu propia cuenta' });
    }
    
    // Verificar email √∫nico (excluyendo el usuario actual)
    if (email) {
      const emailExiste = usuarios.find(u => u.email.toLowerCase() === email.toLowerCase() && u.id !== id);
      if (emailExiste) {
        return res.status(400).json({ error: 'El email ya est√° registrado' });
      }
    }
    
    // Verificar que el rol existe
    if (rolId) {
      const rol = roles.find(r => r.id === parseInt(rolId));
      if (!rol) {
        return res.status(400).json({ error: 'Rol inv√°lido' });
      }
    }
    
    // Actualizar usuario
    usuarios[usuarioIndex] = {
      ...usuarios[usuarioIndex],
      ...(nombre && { nombre }),
      ...(email && { email: email.toLowerCase() }),
      ...(rolId && { rolId: parseInt(rolId) }),
      ...(activo !== undefined && { activo })
    };
    
    const usuarioActualizado = usuarios[usuarioIndex];
    const rol = roles.find(r => r.id === usuarioActualizado.rolId);
    const { password, ...usuarioSinPassword } = usuarioActualizado;
    
    res.json({
      ...usuarioSinPassword,
      rol: {
        id: rol.id,
        nombre: rol.nombre
      }
    });
  } catch (error) {
    res.status(500).json({ error: 'Error al actualizar usuario' });
  }
});

app.post('/api/usuarios/:id/reset-password', authenticateToken, authorize(['Administrador']), (req, res) => {
  try {
    const id = parseInt(req.params.id);
    
    const usuarioIndex = usuarios.findIndex(u => u.id === id);
    if (usuarioIndex === -1) {
      return res.status(404).json({ error: 'Usuario no encontrado' });
    }
    
    // Generar nueva contrase√±a temporal
    const nuevaPassword = generateRandomPassword();
    
    // Actualizar contrase√±a
    usuarios[usuarioIndex].password = hashPasswordMD5(nuevaPassword);
    
    const usuario = usuarios[usuarioIndex];
    
    res.json({
      mensaje: 'Contrase√±a reseteada exitosamente',
      usuario: {
        id: usuario.id,
        nombre: usuario.nombre,
        email: usuario.email
      },
      nuevasCredenciales: {
        email: usuario.email,
        password: nuevaPassword,
        mensaje: 'Entrega estas credenciales al usuario para que pueda acceder'
      }
    });
  } catch (error) {
    res.status(500).json({ error: 'Error al resetear contrase√±a' });
  }
});

app.patch('/api/usuarios/:id/toggle-status', authenticateToken, authorize(['Administrador']), (req, res) => {
  try {
    const id = parseInt(req.params.id);
    
    const usuarioIndex = usuarios.findIndex(u => u.id === id);
    if (usuarioIndex === -1) {
      return res.status(404).json({ error: 'Usuario no encontrado' });
    }
    
    // No permitir que el admin se desactive a s√≠ mismo
    if (req.user.id === id && usuarios[usuarioIndex].activo === true) {
      return res.status(400).json({ error: 'No puedes desactivar tu propia cuenta' });
    }
    
    // Cambiar estado
    usuarios[usuarioIndex].activo = !usuarios[usuarioIndex].activo;
    
    const usuario = usuarios[usuarioIndex];
    const rol = roles.find(r => r.id === usuario.rolId);
    const { password, ...usuarioSinPassword } = usuario;
    
    res.json({
      ...usuarioSinPassword,
      rol: {
        id: rol.id,
        nombre: rol.nombre
      }
    });
  } catch (error) {
    res.status(500).json({ error: 'Error al cambiar estado del usuario' });
  }
});

app.get('/api/roles', authenticateToken, authorize(['Administrador']), (req, res) => {
  res.json(roles);
});

// API Endpoints for Categor√≠as
app.get('/api/categorias', authenticateToken, (req, res) => {
  res.json(categorias);
});

// API Endpoints for Productos
app.get('/api/productos', authenticateToken, (req, res) => {
  // Asegurar que todos los productos tengan el campo proveedor
  const productosConProveedor = productos.map(p => ({
    ...p,
    proveedor: p.proveedor || 'Sin proveedor'
  }));

  console.log('GET /api/productos - Devolviendo productos:', productosConProveedor.length);
  res.json(productosConProveedor);
});

app.post('/api/productos', authenticateToken, authorize(['Administrador']), (req, res) => {
  const { nombre, precio, costo, stock_inicial, categoria_id, proveedor_id } = req.body;

  console.log('=== CREAR PRODUCTO DEBUG ===');
  console.log('Body recibido:', req.body);
  console.log('proveedor_id recibido:', proveedor_id, 'Tipo:', typeof proveedor_id);

  // Validar nombre y precio (requeridos)
  if (!nombre || !nombre.trim()) {
    return res.status(400).json({ error: 'El nombre del producto es obligatorio' });
  }
  if (!precio || parseFloat(precio) <= 0) {
    return res.status(400).json({ error: 'El precio de venta debe ser mayor a cero' });
  }

  // Find category (required)
  const categoria = categorias.find(c => c.id === parseInt(categoria_id));
  if (!categoria) {
    return res.status(400).json({ error: 'Categor√≠a no encontrada' });
  }

  // Find provider (optional)
  let proveedorNombre = 'Sin proveedor';
  let proveedorId = null;
  console.log('Proveedores disponibles:', proveedores.map(p => ({ id: p.id, nombre: p.nombre })));

  // Validar que proveedor_id sea un valor v√°lido (no null, undefined, 0, o string vac√≠o)
  if (proveedor_id && proveedor_id !== '' && proveedor_id !== '0' && proveedor_id !== 0) {
    console.log('Buscando proveedor con ID:', proveedor_id, 'parseado como:', parseInt(proveedor_id));
    const proveedor = proveedores.find(p => p.id === parseInt(proveedor_id));
    console.log('Proveedor encontrado:', proveedor);

    if (proveedor) {
      proveedorNombre = proveedor.nombre;
      proveedorId = proveedor.id;
      console.log('‚úÖ Proveedor asignado:', proveedorNombre, 'ID:', proveedorId);
    } else {
      console.log('‚ùå Proveedor NO encontrado para ID:', proveedor_id);
    }
  } else {
    console.log('‚ö†Ô∏è No se proporcion√≥ proveedor_id v√°lido:', proveedor_id);
  }

  // Generar c√≥digo autom√°tico en formato PROD000001
  const codigoGenerado = `PROD${String(nextProductoId).padStart(6, '0')}`;

  const nuevoProducto = {
    id: nextProductoId++,
    codigo: codigoGenerado,
    nombre: nombre.trim(),
    precio: parseFloat(precio),
    costo: costo ? parseFloat(costo) : 0, // Precio de costo inicial (opcional)
    stock: stock_inicial ? parseInt(stock_inicial) : 0,
    categoria: categoria.nombre,
    categoria_id: parseInt(categoria_id),
    proveedor: proveedorNombre,
    proveedor_id: proveedorId,
    activo: true
  };

  console.log('‚úÖ Producto creado:', nuevoProducto);
  console.log('Proveedor en producto:', nuevoProducto.proveedor);
  productos.push(nuevoProducto);
  res.json(nuevoProducto);
});

// Toggle activo/inactivo sin eliminar
app.patch('/api/productos/:id/toggle-status', authenticateToken, authorize(['Administrador']), (req, res) => {
  try {
    const id = parseInt(req.params.id);
    const index = productos.findIndex(p => p.id === id);
    if (index === -1) {
      return res.status(404).json({ error: 'Producto no encontrado' });
    }

    // Toggle activo (if undefined, treat as true)
    productos[index].activo = productos[index].activo === undefined ? false : !productos[index].activo;

    res.json(productos[index]);
  } catch (error) {
    res.status(500).json({ error: 'Error al cambiar estado del producto' });
  }
});

app.put('/api/productos/:id', authenticateToken, authorize(['Administrador']), (req, res) => {
  const id = parseInt(req.params.id);
  const { codigo, nombre, precio, stock, categoria, proveedor } = req.body;
  
  const index = productos.findIndex(p => p.id === id);
  if (index === -1) {
    return res.status(404).json({ error: 'Producto no encontrado' });
  }
  
  productos[index] = {
    ...productos[index],
    codigo,
    nombre,
    precio: parseFloat(precio),
    stock: parseInt(stock),
    categoria,
    proveedor
  };
  
  res.json(productos[index]);
});

app.delete('/api/productos/:id', authenticateToken, authorize(['Administrador']), (req, res) => {
  const id = parseInt(req.params.id);
  const index = productos.findIndex(p => p.id === id);
  
  if (index === -1) {
    return res.status(404).json({ error: 'Producto no encontrado' });
  }
  
  productos.splice(index, 1);
  res.json({ mensaje: 'Producto eliminado con √©xito' });
});

// API Endpoints for Clientes
app.get('/api/clientes', authenticateToken, (req, res) => {
  res.json(clientes);
});

app.post('/api/clientes', authenticateToken, authorize(['Administrador', 'Vendedor']), (req, res) => {
  const { nombre, email, telefono } = req.body;
  
  const nuevoCliente = {
    id: nextClienteId++,
    nombre,
    email,
    telefono
  };
  
  clientes.push(nuevoCliente);
  res.json(nuevoCliente);
});

// API Endpoints for Ventas
app.get('/api/ventas', authenticateToken, (req, res) => {
  const ventasConDetalles = ventas.map(venta => {
    const cliente = clientes.find(c => c.id === venta.clienteId);
    const productosDetalle = venta.productos.map(item => {
      const producto = productos.find(p => p.id === item.productoId);
      return {
        nombre: producto ? producto.nombre : 'Producto no encontrado',
        cantidad: item.cantidad,
        precio: item.precio
      };
    });
    
    return {
      ...venta,
      cliente: cliente ? cliente.nombre : 'Cliente no encontrado',
      productos: productosDetalle
    };
  });
  
  res.json(ventasConDetalles);
});

app.post('/api/ventas', authenticateToken, authorize(['Administrador', 'Vendedor']), (req, res) => {
  const { clienteId, productos: productosVenta, total } = req.body;
  
  // Validate client exists
  const cliente = clientes.find(c => c.id === clienteId);
  if (!cliente) {
    return res.status(400).json({ error: 'Cliente no encontrado' });
  }
  
  // Validate products and update stock
  for (const item of productosVenta) {
    const producto = productos.find(p => p.id === item.productoId);
    if (!producto) {
      return res.status(400).json({ error: `Producto con ID ${item.productoId} no encontrado` });
    }
    if (producto.stock < item.cantidad) {
      return res.status(400).json({ error: `Stock insuficiente para ${producto.nombre}` });
    }
  }
  
  // Update stock
  for (const item of productosVenta) {
    const productoIndex = productos.findIndex(p => p.id === item.productoId);
    productos[productoIndex].stock -= item.cantidad;
  }
  
  const nuevaVenta = {
    id: nextVentaId++,
    clienteId,
    productos: productosVenta,
    total,
    fecha: new Date().toISOString()
  };
  
  ventas.push(nuevaVenta);
  res.json(nuevaVenta);
});

// PDF Generation Endpoint
app.post('/api/comprobantes/:ventaId', authenticateToken, authorize(['Administrador', 'Vendedor']), async (req, res) => {
  const ventaId = parseInt(req.params.ventaId);
  let venta = ventas.find(v => v.id === ventaId);
  
  // If not found in ventas, create mock data for historical comprobantes
  if (!venta) {
    // Mock data for historical comprobantes (IDs 1, 2, 3 from HistorialComprobantes)
    const mockComprobantes = {
      1: {
        id: 1,
        clienteId: 1,
        productos: [{ productoId: 1, cantidad: 1, precio: 187500 }],
        total: 187500,
        fecha: '2023-12-15'
      },
      2: {
        id: 2,
        clienteId: 2,
        productos: [{ productoId: 2, cantidad: 1, precio: 133575 }],
        total: 133575,
        fecha: '2023-12-14'
      },
      3: {
        id: 3,
        clienteId: 3,
        productos: [{ productoId: 3, cantidad: 1, precio: 322613 }],
        total: 322613,
        fecha: '2023-12-13'
      }
    };
    
    venta = mockComprobantes[ventaId];
  }
  
  if (!venta) {
    return res.status(404).json({ error: 'Venta no encontrada' });
  }
  
  const cliente = clientes.find(c => c.id === venta.clienteId);
  
  try {
    const browser = await puppeteer.launch({ headless: 'new' });
    const page = await browser.newPage();
    
    // Generate HTML for the invoice
    const html = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <title>Comprobante de Venta</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 40px; }
          .header { text-align: center; margin-bottom: 30px; }
          .company-name { font-size: 24px; font-weight: bold; color: #2c3e50; }
          .invoice-title { font-size: 18px; margin-top: 10px; }
          .details { margin: 20px 0; }
          .details-row { display: flex; justify-content: space-between; margin: 5px 0; }
          .products-table { width: 100%; border-collapse: collapse; margin: 20px 0; }
          .products-table th, .products-table td { 
            border: 1px solid #ddd; 
            padding: 12px; 
            text-align: left; 
          }
          .products-table th { background-color: #f8f9fa; font-weight: bold; }
          .total { font-size: 18px; font-weight: bold; text-align: right; margin-top: 20px; }
          .footer { margin-top: 40px; text-align: center; font-size: 12px; color: #666; }
        </style>
      </head>
      <body>
        <div class="header">
          <div class="company-name">FERRETER√çA SISTEMA</div>
          <div class="invoice-title">Comprobante de Venta</div>
        </div>
        
        <div class="details">
          <div class="details-row">
            <strong>No. Factura:</strong>
            <span>${venta.id.toString().padStart(6, '0')}</span>
          </div>
          <div class="details-row">
            <strong>Fecha:</strong>
            <span>${new Date(venta.fecha).toLocaleDateString('es-ES')}</span>
          </div>
          <div class="details-row">
            <strong>Cliente:</strong>
            <span>${cliente ? cliente.nombre : 'Cliente no encontrado'}</span>
          </div>
          <div class="details-row">
            <strong>Email:</strong>
            <span>${cliente ? cliente.email : 'N/A'}</span>
          </div>
        </div>
        
        <table class="products-table">
          <thead>
            <tr>
              <th>Producto</th>
              <th>Cantidad</th>
              <th>Precio Unitario</th>
              <th>Subtotal</th>
            </tr>
          </thead>
          <tbody>
            ${venta.productos.map(item => {
              const producto = productos.find(p => p.id === item.productoId);
              const subtotal = item.cantidad * item.precio;
              return `
                <tr>
                  <td>${producto ? producto.nombre : 'Producto no encontrado'}</td>
                  <td>${item.cantidad}</td>
                  <td>$${item.precio.toFixed(2)}</td>
                  <td>$${subtotal.toFixed(2)}</td>
                </tr>
              `;
            }).join('')}
          </tbody>
        </table>
        
        <div class="total">
          <strong>TOTAL: $${venta.total.toFixed(2)}</strong>
        </div>
        
        <div class="footer">
          <p>Gracias por su compra</p>
          <p>Este es un comprobante generado autom√°ticamente</p>
        </div>
      </body>
      </html>
    `;
    
    await page.setContent(html, { waitUntil: 'networkidle0' });
    
    const pdf = await page.pdf({
      format: 'A4',
      margin: {
        top: '20mm',
        right: '20mm',
        bottom: '20mm',
        left: '20mm'
      }
    });
    
    await browser.close();
    
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="comprobante-${ventaId}.pdf"`);
    res.send(pdf);
    
  } catch (error) {
    console.error('Error generating PDF:', error);
    res.status(500).json({ error: 'Error generating PDF' });
  }
});

// API Endpoints for Proveedores
app.get('/api/proveedores', authenticateToken, (req, res) => {
  res.json(proveedores);
});

app.post('/api/proveedores', authenticateToken, authorize(['Administrador']), (req, res) => {
  const { nombre, ruc, email, telefono, direccion } = req.body;

  const nuevoProveedor = {
    id: nextProveedorId++,
    nombre,
    ruc,
    email,
    telefono,
    direccion
  };

  proveedores.push(nuevoProveedor);
  res.json(nuevoProveedor);
});

app.put('/api/proveedores/:id', authenticateToken, authorize(['Administrador']), (req, res) => {
  const id = parseInt(req.params.id);
  const { nombre, ruc, email, telefono, direccion } = req.body;

  const index = proveedores.findIndex(p => p.id === id);
  if (index === -1) {
    return res.status(404).json({ error: 'Proveedor no encontrado' });
  }

  proveedores[index] = {
    ...proveedores[index],
    nombre,
    ruc,
    email,
    telefono,
    direccion
  };

  res.json(proveedores[index]);
});

app.delete('/api/proveedores/:id', authenticateToken, authorize(['Administrador']), (req, res) => {
  const id = parseInt(req.params.id);
  const index = proveedores.findIndex(p => p.id === id);
  
  if (index === -1) {
    return res.status(404).json({ error: 'Proveedor no encontrado' });
  }
  
  proveedores.splice(index, 1);
  res.json({ mensaje: 'Proveedor eliminado con √©xito' });
});

// API Endpoints for Compras
app.get('/api/compras', authenticateToken, authorize(['Administrador']), (req, res) => {
  const comprasConDetalles = compras.map(compra => {
    // Buscar proveedor completo por ID
    const proveedor = proveedores.find(p => p.id === compra.proveedorId);

    // Mapear productos con detalles
    const productosDetalle = compra.productos.map(item => {
      const producto = productos.find(p => p.id === item.productoId);
      return {
        nombre: producto ? producto.nombre : 'Producto no encontrado',
        cantidad: item.cantidad,
        precio: item.precio
      };
    });

    // Retornar compra con todos los datos del proveedor
    return {
      id: compra.id,
      proveedor_id: compra.proveedorId,
      fecha: compra.fecha,
      total: compra.total,
      proveedor: proveedor ? proveedor.nombre : 'Proveedor no encontrado',
      ruc_proveedor: proveedor ? proveedor.ruc : 'N/A',
      telefono_proveedor: proveedor ? proveedor.telefono : 'N/A',
      direccion_proveedor: proveedor ? proveedor.direccion : 'N/A',
      productos: productosDetalle
    };
  });

  console.log('GET /api/compras - Devolviendo compras:', comprasConDetalles.length);
  res.json(comprasConDetalles);
});

app.post('/api/compras', authenticateToken, authorize(['Administrador']), (req, res) => {
  const { proveedorId, productos: productosCompra, total } = req.body;

  console.log('=== COMPRA REQUEST DEBUG ===');
  console.log('Received proveedorId:', proveedorId, 'Type:', typeof proveedorId);
  console.log('Productos de compra:', productosCompra);
  console.log('Available proveedores in backend:', proveedores.map(p => ({ id: p.id, nombre: p.nombre })));

  // Validaciones
  if (!proveedorId) {
    return res.status(400).json({ error: 'Proveedor es obligatorio' });
  }

  if (!productosCompra || productosCompra.length === 0) {
    return res.status(400).json({ error: 'Debe agregar al menos un producto a la compra' });
  }

  // Validate provider exists in backend
  const proveedor = proveedores.find(p => p.id === proveedorId);
  console.log('Found proveedor in backend:', proveedor);

  if (!proveedor) {
    console.log('‚ùå Proveedor no encontrado en backend - ID recibido:', proveedorId);
    console.log('‚ùå IDs disponibles en backend:', proveedores.map(p => p.id));
    return res.status(400).json({ error: 'Proveedor no encontrado' });
  }

  // Validate products, quantities and costs
  for (const item of productosCompra) {
    if (!item.productoId) {
      return res.status(400).json({ error: 'Todos los productos deben estar seleccionados' });
    }

    if (!item.cantidad || item.cantidad <= 0) {
      return res.status(400).json({ error: 'Las cantidades deben ser mayores a cero' });
    }

    if (!item.costo || item.costo <= 0) {
      return res.status(400).json({ error: 'Los costos deben ser mayores a cero' });
    }

    const producto = productos.find(p => p.id === item.productoId);
    if (!producto) {
      return res.status(400).json({ error: `Producto con ID ${item.productoId} no encontrado` });
    }
  }

  // Update stock and cost (increase stock for purchases and update cost)
  for (const item of productosCompra) {
    const productoIndex = productos.findIndex(p => p.id === item.productoId);
    if (productoIndex !== -1) {
      // Incrementar stock
      productos[productoIndex].stock += item.cantidad;
      // Actualizar precio de costo con el √∫ltimo precio de compra
      productos[productoIndex].costo = parseFloat(item.costo);
      console.log(`‚úÖ Producto ${productos[productoIndex].nombre}: Stock +${item.cantidad} = ${productos[productoIndex].stock}, Costo actualizado: ${item.costo}`);
    }
  }

  const nuevaCompra = {
    id: nextCompraId++,
    proveedorId: proveedorId,  // Estandarizado a camelCase
    proveedor: proveedor.nombre,
    ruc_proveedor: proveedor.ruc || 'N/A',
    telefono_proveedor: proveedor.telefono || 'N/A',
    direccion_proveedor: proveedor.direccion || 'N/A',
    productos: productosCompra,
    total,
    fecha: new Date().toISOString()
  };

  console.log('‚úÖ Nueva compra creada:', nuevaCompra);

  compras.push(nuevaCompra);
  res.json(nuevaCompra);
});

// Debug endpoint to show current proveedores
app.get('/api/proveedores/debug', (req, res) => {
  console.log('Current proveedores in backend:', proveedores);
  res.json({ proveedores, count: proveedores.length });
});

// Bulk delete endpoints
app.delete('/api/productos/bulk', authenticateToken, authorize(['Administrador']), (req, res) => {
  const { ids } = req.body;
  
  if (!Array.isArray(ids) || ids.length === 0) {
    return res.status(400).json({ error: 'Se requiere un array de IDs v√°lido' });
  }
  
  console.log('Bulk deleting productos with IDs:', ids);
  
  const originalLength = productos.length;
  productos = productos.filter(p => !ids.includes(p.id));
  const deletedCount = originalLength - productos.length;
  
  console.log(`Deleted ${deletedCount} productos`);
  res.json({ message: `${deletedCount} productos eliminados exitosamente`, deletedCount });
});

app.delete('/api/clientes/bulk', authenticateToken, authorize(['Administrador']), (req, res) => {
  const { ids } = req.body;
  
  if (!Array.isArray(ids) || ids.length === 0) {
    return res.status(400).json({ error: 'Se requiere un array de IDs v√°lido' });
  }
  
  console.log('Bulk deleting clientes with IDs:', ids);
  
  const originalLength = clientes.length;
  clientes = clientes.filter(c => !ids.includes(c.id));
  const deletedCount = originalLength - clientes.length;
  
  console.log(`Deleted ${deletedCount} clientes`);
  res.json({ message: `${deletedCount} clientes eliminados exitosamente`, deletedCount });
});

app.delete('/api/proveedores/bulk', authenticateToken, authorize(['Administrador']), (req, res) => {
  const { ids } = req.body;
  
  if (!Array.isArray(ids) || ids.length === 0) {
    return res.status(400).json({ error: 'Se requiere un array de IDs v√°lido' });
  }
  
  console.log('Bulk deleting proveedores with IDs:', ids);
  
  const originalLength = proveedores.length;
  proveedores = proveedores.filter(p => !ids.includes(p.id));
  const deletedCount = originalLength - proveedores.length;
  
  console.log(`Deleted ${deletedCount} proveedores`);
  res.json({ message: `${deletedCount} proveedores eliminados exitosamente`, deletedCount });
});

app.delete('/api/compras/bulk', authenticateToken, authorize(['Administrador']), (req, res) => {
  const { ids } = req.body;
  
  if (!Array.isArray(ids) || ids.length === 0) {
    return res.status(400).json({ error: 'Se requiere un array de IDs v√°lido' });
  }
  
  console.log('Bulk deleting compras with IDs:', ids);
  
  const originalLength = compras.length;
  compras = compras.filter(c => !ids.includes(c.id));
  const deletedCount = originalLength - compras.length;
  
  console.log(`Deleted ${deletedCount} compras`);
  res.json({ message: `${deletedCount} compras eliminadas exitosamente`, deletedCount });
});

app.delete('/api/ventas/bulk', authenticateToken, authorize(['Administrador']), (req, res) => {
  const { ids } = req.body;
  
  if (!Array.isArray(ids) || ids.length === 0) {
    return res.status(400).json({ error: 'Se requiere un array de IDs v√°lido' });
  }
  
  console.log('Bulk deleting ventas with IDs:', ids);
  
  const originalLength = ventas.length;
  ventas = ventas.filter(v => !ids.includes(v.id));
  const deletedCount = originalLength - ventas.length;
  
  console.log(`Deleted ${deletedCount} ventas`);
  res.json({ message: `${deletedCount} ventas eliminadas exitosamente`, deletedCount });
});

// Health check endpoint
app.get('/api/health', (req, res) => {
  res.json({ status: 'OK', timestamp: new Date().toISOString() });
});

// Iniciar servidor
const PORT = 4000;
app.listen(PORT, () => {
  console.log(`üöÄ Servidor backend corriendo en http://localhost:${PORT}`);
  console.log(`üìä Endpoints disponibles:`);
  console.log(`   üîê Auth:`);
  console.log(`     POST /api/auth/login`);
  console.log(`     GET  /api/auth/me`);
  console.log(`   üì¶ Productos (requiere auth):`);
  console.log(`     GET  /api/productos`);
  console.log(`     POST /api/productos (Admin)`);
  console.log(`     PUT  /api/productos/:id (Admin)`);
  console.log(`     DELETE /api/productos/:id (Admin)`);
  console.log(`   üìÇ Categor√≠as (requiere auth):`);
  console.log(`     GET  /api/categorias`);
  console.log(`   üë• Clientes (requiere auth):`);
  console.log(`     GET  /api/clientes`);
  console.log(`     POST /api/clientes (Admin/Vendedor)`);
  console.log(`   üè™ Proveedores (requiere auth):`);
  console.log(`     GET  /api/proveedores`);
  console.log(`     POST /api/proveedores (Admin)`);
  console.log(`     PUT  /api/proveedores/:id (Admin)`);
  console.log(`     DELETE /api/proveedores/:id (Admin)`);
  console.log(`   üõí Ventas (requiere auth):`);
  console.log(`     GET  /api/ventas`);
  console.log(`     POST /api/ventas (Admin/Vendedor)`);
  console.log(`     POST /api/comprobantes/:ventaId (Admin/Vendedor)`);
  console.log(`   üõçÔ∏è Compras (requiere auth):`);
  console.log(`     GET  /api/compras`);
  console.log(`     POST /api/compras (Admin/Vendedor)`);
  console.log(`   ‚ö° Health:`);
  console.log(`     GET  /api/health`);
  console.log(`\nüîë Usuarios por defecto:`);
  console.log(`   admin@ferreteria.com / admin123 (Administrador)`);
  console.log(`   vendedor@ferreteria.com / vendedor123 (Vendedor)`);
});